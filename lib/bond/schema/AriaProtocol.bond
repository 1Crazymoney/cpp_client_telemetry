// Baked from BondDataPackage.bond from infrastructure_data_pipe with the following recipe:
//   1) Take BondDataPackage.bond
//   2) Filter only relevant types and fields:
//        BondPIIScrubber               -all-
//        BondRecordType                -all-
//        BondPII                       [1, 2, 3]
//        BondClientToCollectorRequest  [1, 2, 3]
//        BondRecord                    [1, 3, 5, 6, 13, 24, 30]
//        BondDataPackage               [1, 2, 3, 4, 5, 6, 7, 8]
//        BondPIIKind                   -all-
//   3) Change namespace to AriaProtocol
//   4) Remove Bond* prefix of type names
//   5) Remove default 'nothing' for strings to avoid maybe<>
//   6) Cleanup (trailing whitespace, extra lines, formatting etc.)

namespace AriaProtocol;

// An enum with all the supported types for a record.
enum RecordType
{
  NotSet = 0,
  Event = 1,
  PerformanceCounter = 2,
  Anomaly = 3,
  Prediction = 4,
  TraceLog = 5,
  EventSourceLog = 6,
  HttpLog = 7,
  PerformanceCounterAzure = 8,
  PerformanceCounterGfs = 9
};

// The various PII Scrubbers that we support.
enum PIIScrubber
{
  NotSet = 0,
  O365 = 1,
  SkypeBI = 2,
  SkypeData = 3
};

enum PIIKind
{
  NotSet = 0,
  DistinguishedName = 1,
  GenericData = 2,
  IPV4Address = 3,
  IPv6Address = 4,
  MailSubject = 5,
  PhoneNumber = 6,
  QueryString = 7,
  SipAddress = 8,
  SmtpAddress = 9,
  Identity = 10,
  Uri = 11,
  Fqdn = 12,
  IPV4AddressLegacy = 13
};

// Contains information on how to scrub and what the content is
struct PII
{
  // This specifies whether we should use a O365Scrubber or SkypeBIScrubber or DataRVScrubber and any others that we might support.
  1: optional PIIScrubber ScrubType = NotSet;

  // Specifies what type of PII is being sent.
  2: optional PIIKind Kind = NotSet;

  // This content will be PII when its sent to the collector.
  3: optional string RawContent;
};

enum CustomerContentKind

{

  NotSet = 0,
  
  GenericContent = 1

}



struct CustomerContent

{

  // Customer content type
  
  1: optional CustomerContentKind Kind = NotSet;

  // Customer content sent to the collector
  
  2: optional string RawContent;

}

// One instance of a log Record.
struct Record
{
  1: optional string Id;
  3: optional int64 Timestamp = 0;
  5: optional string Type;
  6: optional string EventType;
  13: optional map<string, string> Extension;
  24: optional RecordType RecordType = NotSet;
  30: optional map<string, PII> PIIExtensions;
  31: optional map<string, bool> TypedExtensionBoolean;

  32: optional map<string, int64> TypedExtensionDateTime;
  
  33: optional map<string, int64> TypedExtensionInt64;
  
  34: optional map<string, double> TypedExtensionDouble;

  
  // guid is encoded using this format: https://msdn.microsoft.com/en-us/library/system.guid.tobytearray(v=vs.110).aspx
  // so this is always 16 element long
  
  35: optional map<string, vector<uint8>> TypedExtensionGuid;
  
  36: optional map<string, CustomerContent> CustomerContentExtensions;
};

// Container for a group of Records from the same Source.
struct DataPackage
{
  1: optional string Type;
  2: optional string Source;
  3: optional string Version;
  4: optional map<string, string> Ids;
  5: optional string DataPackageId;
  6: optional int64 Timestamp = 0;
  7: optional int32 SchemaVersion = 1;
  8: optional vector<Record> Records;
};

// The top-level struct that is used between clients and the Collectors.
struct ClientToCollectorRequest
{
  1: optional vector<DataPackage> DataPackages;
  2: optional int32 RequestRetryCount;
  3: optional map<string, vector<DataPackage>> TokenToDataPackagesMap;
};
