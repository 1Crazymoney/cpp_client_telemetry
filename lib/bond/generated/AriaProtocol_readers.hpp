//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : bondjson2cpp 2016.12.18.1
//   File : AriaProtocol.json
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once
#include "BondConstTypes.hpp"

namespace bond_lite {

template<typename TReader>
bool Deserialize(TReader& reader, ::AriaProtocol::PII& value, bool isBase)
{
    if (!reader.ReadStructBegin(isBase)) {
        return false;
    }

    uint8_t type;
    uint16_t id;
    for (;;) {
        if (!reader.ReadFieldBegin(type, id)) {
            return false;
        }

        if (type == BT_STOP || type == BT_STOP_BASE) {
            if (isBase != (type == BT_STOP_BASE)) {
                return false;
            }
            break;
        }

        switch (id) {
            case 1: {
                static_assert(sizeof(value.ScrubType) == 4, "Invalid size of enum");
                int32_t item4;
                if (!reader.ReadInt32(item4)) {
                    return false;
                }
                value.ScrubType = static_cast< ::AriaProtocol::PIIScrubber>(item4);
                break;
            }

            case 2: {
                static_assert(sizeof(value.Kind) == 4, "Invalid size of enum");
                int32_t item4;
                if (!reader.ReadInt32(item4)) {
                    return false;
                }
                value.Kind = static_cast< ::AriaProtocol::PIIKind>(item4);
                break;
            }

            case 3: {
                if (!reader.ReadString(value.RawContent)) {
                    return false;
                }
                break;
            }

            default:
                return false;
        }

        if (!reader.ReadFieldEnd()) {
            return false;
        }
    }

    if (!reader.ReadStructEnd(isBase)) {
        return false;
    }

    return true;
}

template<typename TReader>
bool Deserialize(TReader& reader, ::AriaProtocol::Record& value, bool isBase)
{
    if (!reader.ReadStructBegin(isBase)) {
        return false;
    }

    uint8_t type;
    uint16_t id;
    for (;;) {
        if (!reader.ReadFieldBegin(type, id)) {
            return false;
        }

        if (type == BT_STOP || type == BT_STOP_BASE) {
            if (isBase != (type == BT_STOP_BASE)) {
                return false;
            }
            break;
        }

        switch (id) {
            case 1: {
                if (!reader.ReadString(value.Id)) {
                    return false;
                }
                break;
            }

            case 3: {
                if (!reader.ReadInt64(value.Timestamp)) {
                    return false;
                }
                break;
            }

            case 5: {
                if (!reader.ReadString(value.Type)) {
                    return false;
                }
                break;
            }

            case 6: {
                if (!reader.ReadString(value.EventType)) {
                    return false;
                }
                break;
            }

            case 13: {
                uint32_t size4;
                uint8_t keyType4, valueType4;
                if (!reader.ReadMapContainerBegin(size4, keyType4, valueType4)) {
                    return false;
                }
                if (keyType4 != BT_STRING || valueType4 != BT_STRING) {
                    return false;
                }
                for (unsigned i4 = 0; i4 < size4; i4++) {
                    std::string key4;
                    if (!reader.ReadString(key4)) {
                        return false;
                    }
                    if (!reader.ReadString(value.Extension[key4])) {
                        return false;
                    }
                }
                if (!reader.ReadContainerEnd()) {
                    return false;
                }
                break;
            }

            case 24: {
                static_assert(sizeof(value.RecordType) == 4, "Invalid size of enum");
                int32_t item4;
                if (!reader.ReadInt32(item4)) {
                    return false;
                }
                value.RecordType = static_cast< ::AriaProtocol::RecordType>(item4);
                break;
            }

            case 30: {
                uint32_t size4;
                uint8_t keyType4, valueType4;
                if (!reader.ReadMapContainerBegin(size4, keyType4, valueType4)) {
                    return false;
                }
                if (keyType4 != BT_STRING || valueType4 != BT_STRUCT) {
                    return false;
                }
                for (unsigned i4 = 0; i4 < size4; i4++) {
                    std::string key4;
                    if (!reader.ReadString(key4)) {
                        return false;
                    }
                    if (!Deserialize(reader, value.PIIExtensions[key4], false)) {
                        return false;
                    }
                }
                if (!reader.ReadContainerEnd()) {
                    return false;
                }
                break;
            }

            default:
                return false;
        }

        if (!reader.ReadFieldEnd()) {
            return false;
        }
    }

    if (!reader.ReadStructEnd(isBase)) {
        return false;
    }

    return true;
}

template<typename TReader>
bool Deserialize(TReader& reader, ::AriaProtocol::DataPackage& value, bool isBase)
{
    if (!reader.ReadStructBegin(isBase)) {
        return false;
    }

    uint8_t type;
    uint16_t id;
    for (;;) {
        if (!reader.ReadFieldBegin(type, id)) {
            return false;
        }

        if (type == BT_STOP || type == BT_STOP_BASE) {
            if (isBase != (type == BT_STOP_BASE)) {
                return false;
            }
            break;
        }

        switch (id) {
            case 1: {
                if (!reader.ReadString(value.Type)) {
                    return false;
                }
                break;
            }

            case 2: {
                if (!reader.ReadString(value.Source)) {
                    return false;
                }
                break;
            }

            case 3: {
                if (!reader.ReadString(value.Version)) {
                    return false;
                }
                break;
            }

            case 4: {
                uint32_t size4;
                uint8_t keyType4, valueType4;
                if (!reader.ReadMapContainerBegin(size4, keyType4, valueType4)) {
                    return false;
                }
                if (keyType4 != BT_STRING || valueType4 != BT_STRING) {
                    return false;
                }
                for (unsigned i4 = 0; i4 < size4; i4++) {
                    std::string key4;
                    if (!reader.ReadString(key4)) {
                        return false;
                    }
                    if (!reader.ReadString(value.Ids[key4])) {
                        return false;
                    }
                }
                if (!reader.ReadContainerEnd()) {
                    return false;
                }
                break;
            }

            case 5: {
                if (!reader.ReadString(value.DataPackageId)) {
                    return false;
                }
                break;
            }

            case 6: {
                if (!reader.ReadInt64(value.Timestamp)) {
                    return false;
                }
                break;
            }

            case 7: {
                if (!reader.ReadInt32(value.SchemaVersion)) {
                    return false;
                }
                break;
            }

            case 8: {
                uint32_t size4;
                uint8_t type4;
                if (!reader.ReadContainerBegin(size4, type4)) {
                    return false;
                }
                if (type4 != BT_STRUCT) {
                    return false;
                }
                value.Records.resize(size4);
                for (unsigned i4 = 0; i4 < size4; i4++) {
                    if (!Deserialize(reader, value.Records[i4], false)) {
                        return false;
                    }
                }
                if (!reader.ReadContainerEnd()) {
                    return false;
                }
                break;
            }

            default:
                return false;
        }

        if (!reader.ReadFieldEnd()) {
            return false;
        }
    }

    if (!reader.ReadStructEnd(isBase)) {
        return false;
    }

    return true;
}

template<typename TReader>
bool Deserialize(TReader& reader, ::AriaProtocol::ClientToCollectorRequest& value, bool isBase)
{
    if (!reader.ReadStructBegin(isBase)) {
        return false;
    }

    uint8_t type;
    uint16_t id;
    for (;;) {
        if (!reader.ReadFieldBegin(type, id)) {
            return false;
        }

        if (type == BT_STOP || type == BT_STOP_BASE) {
            if (isBase != (type == BT_STOP_BASE)) {
                return false;
            }
            break;
        }

        switch (id) {
            case 1: {
                uint32_t size4;
                uint8_t type4;
                if (!reader.ReadContainerBegin(size4, type4)) {
                    return false;
                }
                if (type4 != BT_STRUCT) {
                    return false;
                }
                value.DataPackages.resize(size4);
                for (unsigned i4 = 0; i4 < size4; i4++) {
                    if (!Deserialize(reader, value.DataPackages[i4], false)) {
                        return false;
                    }
                }
                if (!reader.ReadContainerEnd()) {
                    return false;
                }
                break;
            }

            case 2: {
                if (!reader.ReadInt32(value.RequestRetryCount)) {
                    return false;
                }
                break;
            }

            case 3: {
                uint32_t size4;
                uint8_t keyType4, valueType4;
                if (!reader.ReadMapContainerBegin(size4, keyType4, valueType4)) {
                    return false;
                }
                if (keyType4 != BT_STRING || valueType4 != BT_LIST) {
                    return false;
                }
                for (unsigned i4 = 0; i4 < size4; i4++) {
                    std::string key4;
                    if (!reader.ReadString(key4)) {
                        return false;
                    }
                    uint32_t size5;
                    uint8_t type5;
                    if (!reader.ReadContainerBegin(size5, type5)) {
                        return false;
                    }
                    if (type5 != BT_STRUCT) {
                        return false;
                    }
                    value.TokenToDataPackagesMap[key4].resize(size5);
                    for (unsigned i5 = 0; i5 < size5; i5++) {
                        if (!Deserialize(reader, value.TokenToDataPackagesMap[key4][i5], false)) {
                            return false;
                        }
                    }
                    if (!reader.ReadContainerEnd()) {
                        return false;
                    }
                }
                if (!reader.ReadContainerEnd()) {
                    return false;
                }
                break;
            }

            default:
                return false;
        }

        if (!reader.ReadFieldEnd()) {
            return false;
        }
    }

    if (!reader.ReadStructEnd(isBase)) {
        return false;
    }

    return true;
}

} // namespace bond_lite
